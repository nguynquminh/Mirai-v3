const axios = require("axios");
const fs = require("fs");
const path = require("path");
const request = require("request");

// Utility function
async function getStreamFromURL(url) {
    return new Promise((resolve, reject) => {
        request(url)
            .on("response", function(res) {
                if (res.statusCode !== 200) return reject();
            })
            .on("error", reject)
            .pipe(fs.createWriteStream("tmp.jpg")).on("finish", () => {
                resolve(fs.createReadStream("tmp.jpg"));
            });
    });
}

module.exports.config = {
    name: "aov",
    version: "2.1.0",
    hasPermssion: 0,
    credits: "qm",
    description: "H·ªá th·ªëng tra c·ª©u AOV s·ª≠ d·ª•ng handle reply",
    commandCategory: "Th√¥ng tin",
    usages: "",
    cooldowns: 5
};

const API_BASE = "https://aov-api.onrender.com/api";

// Thay ƒë·ªïi ph·∫ßn main menu
module.exports.run = async function({
    api,
    event
}) {
    const {
        threadID
    } = event;

    const menuMessage = `‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë   üéÆ AOV TRA C·ª®U üéÆ   ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

üìå ùó©ùòÇùó∂ ùóπùóºÃÄùóªùó¥ ùó∞ùóµùóºÃ£ùóª ùó∞ùóµùòÇÃõÃÅùó∞ ùóªùóÆÃÜùóªùó¥:

‚îè‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îì
‚îÉ ùü≠. üßô‚Äç‚ôÇÔ∏è ùóßùóµùóºÃÇùóªùó¥ ùòÅùó∂ùóª ùòÅùòÇÃõùóºÃõÃÅùóªùó¥
‚îÉ ùüÆ. üõ°Ô∏è ùóßùóøùóÆùóªùó¥ ùóØùó∂Ã£
‚îÉ ùüØ. üíé ùó°ùó¥ùóºÃ£ùó∞
‚îÉ ùü∞. ‚ú® ùó£ùóµùó≤ÃÅùóΩ ùóØùóºÃÇÃâ ùòÅùóøùóºÃõÃ£
‚îÉ ùü±. üèÜ ùó£ùóµùòÇÃÄ ùóµùó∂ùó≤Ã£ÃÇùòÇ
‚îÉ ùü≤. üé≤ ùóñùóµùó≤ÃÇÃÅ ƒëùóºÃ£ÃÇ ùó∞ùóµùóºÃõùó∂
‚îó‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îõ

üìù ùó•ùó≤ùóΩùóπùòÜ ùòÄùóºÃÇÃÅ ùòÅùòÇÃõùóºÃõùóªùó¥ ùòÇÃõÃÅùóªùó¥ ƒëùó≤ÃÇÃâ ùó∞ùóµùóºÃ£ùóª`;

    return api.sendMessage(menuMessage, threadID, (err, info) => {
        global.client.handleReply.push({
            name: "aov",
            messageID: info.messageID,
            author: event.senderID,
            type: "mainMenu"
        });
    });
};

module.exports.handleReply = async function({
    api,
    event,
    handleReply
}) {
    const {
        threadID,
        body,
        senderID
    } = event;
    const {
        type,
        author,
        data = {},
        page = 1
    } = handleReply;

    if (senderID !== author) return;

    try {
        const input = body.trim().toLowerCase();

        // Main menu handler
        if (type === "mainMenu") {
            const choice = parseInt(input);
            if (isNaN(choice)) return api.sendMessage("‚ö†Ô∏è Vui l√≤ng nh·∫≠p s·ªë t·ª´ 1-6", threadID);

            switch (choice) {
                case 1: // Hero
                    const heroes = await getHeroes();
                    return sendHeroList(api, threadID, senderID, heroes);
                case 2: // Equipment
                    const equips = await getEquipments();
                    return sendEquipList(api, threadID, senderID, equips);
                case 3: // Rune
                    const runes = await getRunes();
                    return sendRuneList(api, threadID, senderID, runes);
                case 4: // Spell
                    const spells = await getSpells();
                    return sendSpellList(api, threadID, senderID, spells);
                case 5: // Badge
                    const badges = await getBadges();
                    return sendBadgeList(api, threadID, senderID, badges);
                case 6: // Game Mode
                    const gameModes = await getGameModes();
                    return sendGameModeList(api, threadID, senderID, gameModes);
                default:
                    return api.sendMessage("‚ö†Ô∏è Vui l√≤ng ch·ªçn s·ªë t·ª´ 1-6", threadID);
            }
        }

        // Hero handlers
        if (type === "heroList") {
            if (input === "back") return mainMenu(api, threadID, senderID);

            if (input.startsWith("info ")) {
                const heroName = input.split("info ")[1];
                const hero = await searchHero(heroName);
                if (!hero) return api.sendMessage("‚ùå Kh√¥ng t√¨m th·∫•y t∆∞·ªõng", threadID);
                return sendHeroDetail(api, threadID, senderID, hero);
            }

            const newPage = parseInt(input);
            if (!isNaN(newPage)) {
                return sendHeroList(api, threadID, senderID, data.heroes, newPage);
            }

            return api.sendMessage("‚ö†Ô∏è Vui l√≤ng nh·∫≠p s·ªë trang ho·∫∑c 'info <t√™n>'", threadID);
        }

        if (type === "heroDetail") {
            if (input === "back") return sendHeroList(api, threadID, senderID, data.heroes);
            if (input === "skill") return sendHeroSkills(api, threadID, senderID, data.hero);
            if (input === "skin") return sendHeroSkins(api, threadID, senderID, data.hero);
            return api.sendMessage("‚ö†Ô∏è Vui l√≤ng reply 'skill', 'skin' ho·∫∑c 'back'", threadID);
        }

        // Equipment handlers
        if (type === "equipList") {
            if (input === "back") return mainMenu(api, threadID, senderID);

            if (input.startsWith("search ")) {
                const equipName = input.split("search ")[1];
                const equip = await searchEquipment(equipName);
                if (!equip) return api.sendMessage("‚ùå Kh√¥ng t√¨m th·∫•y trang b·ªã", threadID);
                return sendEquipDetail(api, threadID, senderID, equip);
            }

            const newPage = parseInt(input);
            if (!isNaN(newPage)) {
                return sendEquipList(api, threadID, senderID, data.equips, newPage);
            }

            return api.sendMessage("‚ö†Ô∏è Vui l√≤ng nh·∫≠p s·ªë trang ho·∫∑c 'search <t√™n>'", threadID);
        }

        // Rune handlers
        if (type === "runeList") {
            if (input === "back") return mainMenu(api, threadID, senderID);

            if (input.startsWith("search ")) {
                const runeName = input.split("search ")[1];
                const rune = await searchRune(runeName);
                if (!rune) return api.sendMessage("‚ùå Kh√¥ng t√¨m th·∫•y ng·ªçc", threadID);
                return sendRuneDetail(api, threadID, senderID, rune);
            }

            const newPage = parseInt(input);
            if (!isNaN(newPage)) {
                return sendRuneList(api, threadID, senderID, data.runes, newPage);
            }

            return api.sendMessage("‚ö†Ô∏è Vui l√≤ng nh·∫≠p s·ªë trang ho·∫∑c 'search <t√™n>'", threadID);
        }

        // Spell handlers
        if (type === "spellList") {
            if (input === "back") return mainMenu(api, threadID, senderID);

            if (input.startsWith("search ")) {
                const spellName = input.split("search ")[1];
                const spell = await searchSpell(spellName);
                if (!spell) return api.sendMessage("‚ùå Kh√¥ng t√¨m th·∫•y ph√©p", threadID);
                return sendSpellDetail(api, threadID, senderID, spell);
            }

            const newPage = parseInt(input);
            if (!isNaN(newPage)) {
                return sendSpellList(api, threadID, senderID, data.spells, newPage);
            }

            return api.sendMessage("‚ö†Ô∏è Vui l√≤ng nh·∫≠p s·ªë trang ho·∫∑c 'search <t√™n>'", threadID);
        }

        // Badge handlers
        if (type === "badgeList") {
            if (input === "back") return mainMenu(api, threadID, senderID);

            const badgeIndex = parseInt(input) - 1;
            if (!isNaN(badgeIndex) && badgeIndex >= 0 && badgeIndex < data.badges.length) {
                return sendBadgeDetail(api, threadID, senderID, data.badges[badgeIndex]);
            }

            return api.sendMessage("‚ö†Ô∏è Vui l√≤ng nh·∫≠p s·ªë th·ª© t·ª±", threadID);
        }

        if (type === "badgeDetail") {
            if (input === "back") return sendBadgeList(api, threadID, senderID, data.badges);

            const skillIndex = parseInt(input) - 1;
            if (!isNaN(skillIndex)) {
                const allSkills = data.badge.groups.reduce((arr, g) => arr.concat(g.skills), []);
                if (skillIndex >= 0 && skillIndex < allSkills.length) {
                    return sendSkillDetail(api, threadID, senderID, allSkills[skillIndex], data.badge);
                }
            }

            const foundSkill = data.badge.groups
                .reduce((arr, g) => arr.concat(g.skills), [])
                .find(s => s.name.toLowerCase() === input);

            if (foundSkill) {
                return sendSkillDetail(api, threadID, senderID, foundSkill, data.badge);
            }

            const suggestions = data.badge.groups
                .reduce((arr, g) => arr.concat(g.skills), [])
                .map(s => `üîπ ${s.name}`)
                .join("\n");

            return api.sendMessage(
                `‚ùå Kh√¥ng t√¨m th·∫•y k·ªπ nƒÉng \"${body.trim()}\".\nüìå G·ª£i √Ω:\n\n${suggestions}`,
                threadID
            );
        }

        // Game Mode handlers
        if (type === "gameModeList") {
            if (input === "back") return mainMenu(api, threadID, senderID);

            if (input.startsWith("search ")) {
                const modeName = input.split("search ")[1];
                const gameMode = await searchGameMode(modeName);
                if (!gameMode) return api.sendMessage("‚ùå Kh√¥ng t√¨m th·∫•y ch·∫ø ƒë·ªô ch∆°i", threadID);
                return sendGameModeDetail(api, threadID, senderID, gameMode);
            }

            const newPage = parseInt(input);
            if (!isNaN(newPage)) {
                return sendGameModeList(api, threadID, senderID, data.gameModes, newPage);
            }

            return api.sendMessage("‚ö†Ô∏è Vui l√≤ng nh·∫≠p s·ªë trang ho·∫∑c 'search <t√™n>'", threadID);
        }

        if (type === "gameModeDetail") {
            if (input === "back") return sendGameModeList(api, threadID, senderID, data.gameModes);
            return api.sendMessage("‚ö†Ô∏è Vui l√≤ng reply 'back' ƒë·ªÉ quay l·∫°i", threadID);
        }

    } catch (error) {
        console.error(error);
        return api.sendMessage("‚ùå ƒê√£ x·∫£y ra l·ªói khi x·ª≠ l√Ω y√™u c·∫ßu", threadID);
    }
};

// ====================== HELPER FUNCTIONS ======================
async function mainMenu(api, threadID, senderID) {
    return api.sendMessage(
        "‚öîÔ∏è AOV Tra C·ª©u - Vui l√≤ng ch·ªçn ch·ª©c nƒÉng:\n\n" +
        "1. Th√¥ng tin t∆∞·ªõng\n" +
        "2. Trang b·ªã\n" +
        "3. Ng·ªçc\n" +
        "4. Ph√©p b·ªï tr·ª£\n" +
        "5. Ph√π hi·ªáu\n\n" +
        "üí¨ Reply s·ªë t∆∞∆°ng ·ª©ng ƒë·ªÉ ch·ªçn",
        threadID,
        (err, info) => {
            global.client.handleReply.push({
                name: "aov",
                messageID: info.messageID,
                author: senderID,
                type: "mainMenu"
            });
        }
    );
}

// Hero functions
async function sendHeroList(api, threadID, senderID, heroes, page = 1) {
    const perPage = 10;
    const totalPages = Math.ceil(heroes.length / perPage);
    const start = (page - 1) * perPage;
    const paginated = heroes.slice(start, start + perPage);

    let listMessage = `‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ
‚îÇ üìú ùóóùóîùó°ùóõ ùó¶ùóîÃÅùóñùóõ ùóßùó®Ãõùó¢ÃõÃÅùó°ùóö ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Trang: ${page}/${totalPages}          ‚îÇ
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ\n\n`;

    paginated.forEach((h, i) => {
        listMessage += `‚ñ∏ ${start + i + 1}. ${h.name}\n`;
    });

    listMessage += `
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üìå ùóßùòÇÃÄùòÜ ùó∞ùóµùóºÃ£ùóª:
  üîπ ùó•ùó≤ùóΩùóπùòÜ ùòÄùóºÃÇÃÅ ùòÅùóøùóÆùóªùó¥ ‚Üí ùòÖùó≤ùó∫ ùòÅùó∂ùó≤ÃÇÃÅùóΩ
  üîπ ùó•ùó≤ùóΩùóπùòÜ 'ùó∂ùóªùó≥ùóº <ùòÅùó≤ÃÇùóª>' ‚Üí ùòÅùóøùóÆ ùó∞ùòÇÃõÃÅùòÇ
  üîπ ùó•ùó≤ùóΩùóπùòÜ 'ùóØùóÆùó∞ùó∏' ‚Üí ùòÉùó≤ÃÇÃÄ ùó∫ùó≤ùóªùòÇ`;

    return api.sendMessage(listMessage, threadID, (err, info) => {
        global.client.handleReply.push({
            name: "aov",
            messageID: info.messageID,
            author: senderID,
            type: "heroList",
            data: {
                heroes
            },
            page
        });
    });
}

async function sendHeroDetail(api, threadID, senderID, hero) {
    const img = await axios.get(hero.image, {
        responseType: "stream"
    });

    const cardMessage = `‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë    üßô‚Äç‚ôÇÔ∏è ${hero.name.toUpperCase()}    ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

‚ñ∏ üìå ùóßùóµùóºÃÇùóªùó¥ ùòÅùó∂ùóª ùó∞ùóºÃõ ùóØùóÆÃâùóª:
   ‚ï∞‚îÄ‚ú¶ ƒê·ªô kh√≥: ${hero.difficulty || 'Ch∆∞a c·∫≠p nh·∫≠t'}
   ‚ï∞‚îÄ‚ú¶ V·ªã tr√≠: ${hero.role || 'Ch∆∞a c·∫≠p nh·∫≠t'}

‚ñ∏ üîó ùóüùó∂ùóªùó∏ ùòÅùóøùóÆ ùó∞ùòÇÃõÃÅùòÇ: ${hero.url}

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üí° ùóßùòÇÃÄùòÜ ùó∞ùóµùóºÃ£ùóª:
  üî∏ ùó•ùó≤ùóΩùóπùòÜ 'ùòÄùó∏ùó∂ùóπùóπ' ‚Üí ùòÖùó≤ùó∫ ùó∏ùòÜÃÉ ùóªùóÆÃÜùóªùó¥
  üî∏ ùó•ùó≤ùóΩùóπùòÜ 'ùòÄùó∏ùó∂ùóª' ‚Üí ùòÖùó≤ùó∫ ùòÅùóøùóÆùóªùó¥ ùóΩùóµùòÇÃ£ùó∞
  üî∏ ùó•ùó≤ùóΩùóπùòÜ 'ùóØùóÆùó∞ùó∏' ‚Üí ùóæùòÇùóÆùòÜ ùóπùóÆÃ£ùó∂`;

    return api.sendMessage({
        body: cardMessage,
        attachment: img.data
    }, threadID, (err, info) => {
        global.client.handleReply.push({
            name: "aov",
            messageID: info.messageID,
            author: senderID,
            type: "heroDetail",
            data: {
                hero
            }
        });
    });
}

async function sendHeroSkills(api, threadID, senderID, hero) {
    let skillHeader = `‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ
‚îÇ üåÄ ùóûùó¨ÃÉ ùó°ùóîÃÜùó°ùóö ${hero.name.toUpperCase()} üåÄ ‚îÇ
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ\n\n`;

    for (const s of hero.skills) {
        const attachment = (await axios.get(s.skill_image, {
            responseType: "stream"
        })).data;
        const skillInfo = `‚ñ∏ ùóßùó≤ÃÇùóª: ${s.skill_name}
‚ñ∏ ùóßùó∂ùó≤ÃÇùòÇ ùòÅùóºÃÇÃÅn: ${s.element || 'Ch∆∞a c·∫≠p nh·∫≠t'} mana
‚ñ∏ ùóñùóºùóºùóπùó±ùóºùòÑùóª: ${s.cooldown || 'Ch∆∞a c·∫≠p nh·∫≠t'}s

üìù ùó†ùóºÃÇ ùòÅùóÆÃâ:
${s.description}\n
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`;

        await api.sendMessage({
            body: skillHeader + skillInfo,
            attachment
        }, threadID);
        skillHeader = ''; // Ch·ªâ hi·ªÉn th·ªã header ·ªü skill ƒë·∫ßu ti√™n
    }

    return api.sendMessage(
        "üí¨ ùó•ùó≤ùóΩùóπùòÜ 'ùóØùóÆùó∞ùó∏' ƒëùó≤ÃÇÃâ ùòÉùó≤ÃÇÃÄ ùòÅùóµùóºÃÇùóªùó¥ ùòÅùó∂ùóª ùòÅùòÇÃõùóºÃõÃÅùóªùó¥",
        threadID
    );
}

async function sendHeroSkins(api, threadID, senderID, hero) {
    for (const s of hero.skins) {
        const attachment = (await axios.get(s.skin_image, {
            responseType: "stream"
        })).data;
        await api.sendMessage({
            body: `‚ú® ${s.skin_name}`,
            attachment
        }, threadID);
    }

    return api.sendMessage(
        "üí¨ Reply 'back' ƒë·ªÉ quay l·∫°i th√¥ng tin t∆∞·ªõng",
        threadID,
        (err, info) => {
            global.client.handleReply.push({
                name: "aov",
                messageID: info.messageID,
                author: senderID,
                type: "heroDetail",
                data: {
                    hero,
                    heroes: hero.heroes || []
                }
            });
        }
    );
}

// Equipment functions
async function sendEquipList(api, threadID, senderID, equips, page = 1) {
    const perPage = 10;
    const totalPages = Math.ceil(equips.length / perPage);
    const start = (page - 1) * perPage;
    const paginated = equips.slice(start, start + perPage);

    let msg = `üõ°Ô∏è Danh s√°ch trang b·ªã (Trang ${page}/${totalPages}):\n`;
    paginated.forEach((e, i) => msg += `${start + i + 1}. ${e.name} - ${e.price} v√†ng\n`);
    msg += "\nüí¨ Reply:\n- S·ªë trang ƒë·ªÉ xem ti·∫øp\n- 'search <t√™n>' ƒë·ªÉ t√¨m ki·∫øm\n- 'back' ƒë·ªÉ quay l·∫°i";

    return api.sendMessage(msg, threadID, (err, info) => {
        global.client.handleReply.push({
            name: "aov",
            messageID: info.messageID,
            author: senderID,
            type: "equipList",
            data: {
                equips
            },
            page
        });
    });
}

async function sendEquipDetail(api, threadID, senderID, equip) {
    const stats = equip.stats.map(s => `‚´∏ ${s}`).join("\n");
    const img = await axios.get(equip.image, {
        responseType: "stream"
    });

    const equipCard = `‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë üõ°Ô∏è ${equip.name.toUpperCase()} üõ°Ô∏è ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

‚ñ∏ üí∞ ùóöùó∂ùóÆÃÅ: ${equip.price} v√†ng
‚ñ∏ üìú ùóßùóµùòÇùóºÃ£ÃÇùó∞ ùòÅùó∂ÃÅùóªùóµ:
${stats}

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üí° ùóßùòÇÃÄùòÜ ùó∞ùóµùóºÃ£ùóª:
  üîπ ùó•ùó≤ùóΩùóπùòÜ 'ùóØùóÆùó∞ùó∏' ‚Üí ùòÉùó≤ÃÇÃÄ ùóóùóÆùóªùóµ ùòÄùóÆÃÅùó∞ùóµ`;

    return api.sendMessage({
        body: equipCard,
        attachment: img.data
    }, threadID);
}

// Rune functions
async function sendRuneList(api, threadID, senderID, runes, page = 1) {
    const perPage = 10;
    const totalPages = Math.ceil(runes.length / perPage);
    const start = (page - 1) * perPage;
    const paginated = runes.slice(start, start + perPage);

    let msg = `üíé Danh s√°ch ng·ªçc (Trang ${page}/${totalPages}):\n`;
    paginated.forEach((r, i) => msg += `${start + i + 1}. ${r.name}\n`);
    msg += "\nüí¨ Reply:\n- S·ªë trang ƒë·ªÉ xem ti·∫øp\n- 'search <t√™n>' ƒë·ªÉ t√¨m ki·∫øm\n- 'back' ƒë·ªÉ quay l·∫°i";

    return api.sendMessage(msg, threadID, (err, info) => {
        global.client.handleReply.push({
            name: "aov",
            messageID: info.messageID,
            author: senderID,
            type: "runeList",
            data: {
                runes
            },
            page
        });
    });
}

async function sendRuneDetail(api, threadID, senderID, rune) {
    const stats = rune.stats.join("\n");
    const msg = `üíé ${rune.name}\nüìú Thu·ªôc t√≠nh:\n${stats}`;
    return api.sendMessage(msg, threadID);
}

// Spell functions
async function sendSpellList(api, threadID, senderID, spells, page = 1) {
    const perPage = 9;
    const totalPages = Math.ceil(spells.length / perPage);
    const start = (page - 1) * perPage;
    const paginated = spells.slice(start, start + perPage);

    let msg = `‚ú® Danh s√°ch ph√©p b·ªï tr·ª£ (Trang ${page}/${totalPages}):\n`;
    paginated.forEach((s, i) => msg += `${start + i + 1}. ${s.name}\n`);
    msg += "\nüí¨ Reply:\n- S·ªë trang ƒë·ªÉ xem ti·∫øp\n- 'search <t√™n>' ƒë·ªÉ t√¨m ki·∫øm\n- 'back' ƒë·ªÉ quay l·∫°i";

    return api.sendMessage(msg, threadID, (err, info) => {
        global.client.handleReply.push({
            name: "aov",
            messageID: info.messageID,
            author: senderID,
            type: "spellList",
            data: {
                spells
            },
            page
        });
    });
}

async function sendSpellDetail(api, threadID, senderID, spell) {
    const attachment = await axios.get(spell.image_url, {
        responseType: "stream"
    });
    const msg = `‚ú® ${spell.name}\n‚è±Ô∏è H·ªìi chi√™u: ${spell.cooldown}\nüìú M√¥ t·∫£: ${spell.description}`;

    return api.sendMessage({
        body: msg,
        attachment: attachment.data
    }, threadID);
}

// Badge functions
async function sendBadgeList(api, threadID, senderID, badges) {
    let msg = "üèÜ Danh s√°ch ph√π hi·ªáu:\n\n";
    badges.forEach((b, i) => msg += `${i + 1}. ${b.name}\n${b.description}\n\n`);
    msg += "üí¨ Reply s·ªë th·ª© t·ª± ƒë·ªÉ xem chi ti·∫øt ho·∫∑c 'back' ƒë·ªÉ quay l·∫°i";

    return api.sendMessage(msg, threadID, (err, info) => {
        global.client.handleReply.push({
            name: "aov",
            messageID: info.messageID,
            author: senderID,
            type: "badgeList",
            data: {
                badges
            }
        });
    });
}

async function sendBadgeDetail(api, threadID, senderID, badge) {
    let msg = `‚öúÔ∏è ${badge.name.toUpperCase()} ‚öúÔ∏è\n\nüìù ${badge.description}\n\nüìå C√°c nh√°nh ph·ª•:`;
    badge.groups.forEach((group, i) => {
        msg += `\n\nüåü C·∫•p ${i + 1}:`;
        group.skills.forEach(skill => {
            msg += `\nüî∏ ${skill.name} (${skill.type})`;
        });
    });

    msg += `\n\nüí¨ Reply s·ªë th·ª© t·ª± ho·∫∑c t√™n k·ªπ nƒÉng ƒë·ªÉ xem chi ti·∫øt\n'back' ƒë·ªÉ quay l·∫°i`;

    return api.sendMessage(msg, threadID, (err, info) => {
        global.client.handleReply.push({
            name: "aov",
            messageID: info.messageID,
            author: senderID,
            type: "badgeDetail",
            data: {
                badge,
                badges: badge.badges || []
            }
        });
    });
}

async function sendSkillDetail(api, threadID, senderID, skill, badge) {
    const attachment = await getStreamFromURL(skill.image);
    const msg = `üìõ ${skill.name} (${skill.type})\n\nüìù ${skill.description}`;

    return api.sendMessage({
        body: msg,
        attachment
    }, threadID, (err, info) => {
        global.client.handleReply.push({
            name: "aov",
            messageID: info.messageID,
            author: senderID,
            type: "badgeDetail",
            data: {
                badge,
                badges: badge.badges || []
            }
        });
    });
}

// Game Mode functions
async function sendGameModeList(api, threadID, senderID, gameModes, page = 1) {
    const perPage = 10;
    const totalPages = Math.ceil(gameModes.length / perPage);
    const start = (page - 1) * perPage;
    const paginated = gameModes.slice(start, start + perPage);

    let msg = `‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ
‚îÇ üé≤ ùóóùóîùó°ùóõ ùó¶ùóîÃÅùóñùóõ ùóñùóõùóòÃÇÃÅ ƒêùó¢ÃÇÃ£ ùóñùóõùó¢Ãõùóú ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Trang: ${page}/${totalPages}          ‚îÇ
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ\n\n`;

    paginated.forEach((mode, i) => {
        msg += `‚ñ∏ ${start + i + 1}. ${mode.name}\n`;
    });

    msg += `
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üìå ùóßùòÇÃÄùòÜ ùó∞ùóµùóºÃ£ùóª:
  üîπ ùó•ùó≤ùóΩùóπùòÜ 'ùòÄùó≤ùóÆùóøùó∞ùóµ <ùòÅùó≤ÃÇùóª>' ‚Üí ùòÅùó∂ÃÄùó∫ ùó∏ùó∂ùó≤ÃÇÃÅùó∫
  üîπ ùó•ùó≤ùóΩùóπùòÜ 'ùóØùóÆùó∞ùó∏' ‚Üí ùòÉùó≤ÃÇÃÄ ùó∫ùó≤ùóªùòÇ`;

    return api.sendMessage(msg, threadID, (err, info) => {
        global.client.handleReply.push({
            name: "aov",
            messageID: info.messageID,
            author: senderID,
            type: "gameModeList",
            data: {
                gameModes
            },
            page
        });
    });
}

async function sendGameModeDetail(api, threadID, senderID, gameMode) {
    const img = await axios.get(gameMode.image, {
        responseType: "stream"
    });

    const description = gameMode.description.join("\n   ‚ï∞‚îÄ‚ú¶ ");

    const cardMessage = `‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë üé≤ ${gameMode.name.toUpperCase()} üé≤ ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

‚ñ∏ üìå ùó†ùóºÃÇ ùòÅùóÆÃâ:
   ‚ï∞‚îÄ‚ú¶ ${description}

‚ñ∏ üîó ùóüùó∂ùóªùó∏ ùòÅùóøùóÆ ùó∞ùòÇÃõÃÅùòÇ: ${gameMode.url}

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üí° ùóßùòÇÃÄùòÜ ùó∞ùóµùóºÃ£ùóª:
  üî∏ ùó•ùó≤ùóΩùóπùòÜ 'ùóØùóÆùó∞ùó∏' ‚Üí ùóæùòÇùóÆùòÜ ùóπùóÆÃ£ùó∂`;

    return api.sendMessage({
        body: cardMessage,
        attachment: img.data
    }, threadID, (err, info) => {
        global.client.handleReply.push({
            name: "aov",
            messageID: info.messageID,
            author: senderID,
            type: "gameModeDetail",
            data: {
                gameMode
            }
        });
    });
}

// ====================== API FUNCTIONS ======================
async function getHeroes() {
    const res = await axios.get(`${API_BASE}/heroes`);
    return res.data.data;
}

async function searchHero(name) {
    const heroes = await getHeroes();
    return heroes.find(h => h.name.toLowerCase().includes(name.toLowerCase()));
}

async function getEquipments() {
    const res = await axios.get(`${API_BASE}/equipments`);
    return res.data.data;
}

async function searchEquipment(name) {
    const equips = await getEquipments();
    return equips.find(e => e.name.toLowerCase().includes(name.toLowerCase()));
}

async function getRunes() {
    const res = await axios.get(`${API_BASE}/runes`);
    return res.data.data;
}

async function searchRune(name) {
    const runes = await getRunes();
    return runes.find(r => r.name.toLowerCase().includes(name.toLowerCase()));
}

async function getSpells() {
    const res = await axios.get(`${API_BASE}/spells`);
    return res.data.data;
}

async function searchSpell(name) {
    const spells = await getSpells();
    return spells.find(s => s.name.toLowerCase().includes(name.toLowerCase()));
}

async function getBadges() {
    const res = await axios.get(`${API_BASE}/badges`);
    return res.data.data;
}

async function searchBadge(name) {
    const badges = await getBadges();
    return badges.find(b => b.name.toLowerCase().includes(name.toLowerCase()));
}

async function getGameModes() {
    const res = await axios.get(`${API_BASE}/gamemodes`);
    return res.data.data;
}

async function searchGameMode(name) {
    try {
        const encodedName = encodeURIComponent(name);
        const res = await axios.get(`${API_BASE}/gamemodes/search?q=${encodedName}`);
        return res.data.data?.[0];
    } catch (error) {
        console.error(error);
        return null;
    }
}
